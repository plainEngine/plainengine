#summary документация по Lua API для MPLuaSubject#labels Phase-Implementation,Featured

=Привязки Lua к plainEngine= 
_(Предоставляют полное API plainEngine для Lua)_

<wiki:toc max_depth="3" />

==Основы==
В скрипте могут быть функции _'init', 'start', 'update'_ и _'stop'_.
		* `init` - функция, вызываемая во время запуска субъекта. Она должна содержать код инициализации (создание обьектов, регистрация делегатов и т.д.) и не должна содержать какого-либо кода, зависимого от других субъектов (например, делегируемые вызовы), так как необходимые субъекты могут быть неинициализированны.
		* `start`- функция, вызываемая во время первого обновления. Она может содержать код, зависимый от других субъектов, так как они уже были инициализированы во время `init`.
		* `update` - функция, вызываемая в каждое обновление.
		* `stop` - функция, вызываемая при выходе. Должна содержать код деинициализации и не должна содержать код, зависимый от других субъектов, так как они могут быть уже деинициализированны.

Эти функции не должны содержать ни одного аргумента.

==Работа с логом==
Чтобы отправить сообщение в лог, следуеет использовать функцию `MPLog(level, msg)`
Первый аргумент - это уровень лога (следует испольщовать константы уровня _(info, notice, warning, и т.д.)_). Второй аргумент - это строка, которая должна быть отправленна в лог. Также можно использовать `MPLog(msg)`, что будет эквивалентно `MPLog(notice, msg)`.

==Yield'ы==
Чтобы использовать plainEngine yields, вызывайте функцию `MPYield()`.

==Отправление сообщения==
Чтобы отправить plainEngine-сообщение, следует использовать функцию `MPPostMessage(name[, paramsTable])`. Первый агрумент - это собственно, имя сообщения. Второй (опциональный) аргумент - это lua-таблица с параметрами сообщения.

==Обработка сообщения==
Чтобы обработать какое-либо сообщение, следует объявить функцию - поле таблицы _MPMessageHandlers_ - `MPMessageHandlers.<имя_сообщения>(args)`.
Первым и единственным аргументом передастся lua-таблица с параметрами сообщения. Если вы хотите установить обработчик любого сообщения, обьявите функцию `MPHandlerOfAnyMessage(name, args)`. Тогда первым аргументом передастся имя сообщения, и вторым - таблица параметров.

==Работа с объектами==
Во-первых, обьект - это userinfo с метатаблицей, отвечающей на 4 события - `__index` (которое связывает имена методов с функциями), `__newindex` (который предоставляет простой интерфейс для признаков), `__eq` и `__gc`.

Пока вы можете обратиться к обьекту в вашем скрипте, он является "retained" (Термин Objective-C, означает, что не может быть уничтожен).

Чтобы получить _MPObject_, вам стоит либо использовать таблицу `MPObjects` (имя на обьект) или функцию `MPObjectByName(name)`. Если боьект не найден, вернётся *nil*.

Чтобы создать обьект plainEngine, следует использовать функции `MPNewObject(name)` и `MPCreateObject(name)`. Разница заключается в том, чтоб обьекты, созданные с помощью `MPNewObject`, *должны быть* освобождены вручную с помощью `object.release`, а обьекты, созданные с помощью `MPCreateObject` *НЕ должны быть* уничтожены вручную, так как они будут освобождены автоматически после остановки.

Также можно использовать функции `MPGetAllObjects()` (возвращает массив всех обьектов) и `MPGetObjectsByFeature(featurename)` (возвращает массив всех обьектов с заданным признаком).

Чтобы обращаться к методам обьекта, следует использовать `object:methodname` (или `object["methodName"]` (object, ...) ). Результатом будет функция, аналогичная соответвующему методу. Если имя метода содержит символы ':', вы не можете использовать форму object:methodName, но вы можете использовать _MPMethodAliasTable_. Это глобальная таблица, которая отображает псевдонимы методов на их реальные имена. При вызове метода, в первую очередь проверяется наличие псевдонима для него. Если таковой есть, вызывается метод, соответствующий своему псевдониму. Например, вы хотите сделать выражение`obj["setXYZ:::"](obj 0, 0, 0)` менее уродливым.
Тогда, в 'start', вы обьявляете:
{{{
function start()
	...
	MPMethodAliasTable["setXYZ"] = "setXYZ:::"
	...
end
}}}
И затем, вы можете вызывать `obj.setXYZ(0, 0, 0)`.

Некоторые методы MPObject переопределены в lua-обьекте, так как они использовали типы, не поддерживаемые lua. Это:
		
  # `object:getName()` - возвращает строку с именем обьекта;
  # `object:getHandle()` - возвращает handle обьекта как `number`;
  # `object:hasFeature(fname)` - возвращает `true`, если обьект имеет признак fname и `false` в противном случае;
  # `object:copy()` - возвращает копию обьекта;
  # `object:copyWithName(copyname)` - возвращает копию обьекта с именем _'copyname'_;
  # `object:getAllFeatures()` - возвращает таблицу с названиями признаков в качестве ключей и их значениями в качестве значений (таблицы);
  # `object:getFeatureData(fname)` - возвращает строку со значением признака _'fname'_;
  # `object:setFeature(fname[, fvalue [,paramsTable]])`	- меняет значение признака _'fname'_ на _'fvalue'_ (значение по умолчанию - пустая строка) и paramsTable как userInfo;
  # `object:removeFeature(fname[, paramsTable])` - удаляет признак 'fname' у object, отправляя paramsTable как userInfo при наличии такового;

Если вы хотите сменить значение признака обьекта на некоторое значение без отправления каких-либо параметров, вы можете написать
{{{ 
object.featurename = featurevalue 
}}}
вместо
{{{
object:setFeature(featurename, featurevalue); 
}}}

Но чтение признаков таким образом работать не будет, так как object.name означает метод 'name'.

==Обьявление классов делегатов==
В Lua, класс делегата это таблица, содержащая функцию 'delegateClassTable:newDelegateWithObject(object)' или 'delegateClassTable:new()'. Если вы хотите зарегистрировать класс делегатат, используйте функцию `MPRegisterDelegateClass(delegateClassTable)` или `MPRegisterDelegateClassForFeature(delegateClassTable, featureName)`.

Делегаты инстанцируются через функции класса делегата (`newDelegateWithObject` или `new`). Каждый делегам должен содержать таблицу 'signatures', являющуюся массивом сигнатур метода (тип - `string`) вида: `"<R> methodname:<t1> :<t2> :<t3>"`, где `<R>` - это type encoding возвращаемого значения, `t1` - это type encoding первого аргумента и т.д. (например "d getX" или "v setXYZ:d:d:d").

Сигнатуры могут свободно меняться на протяжении существования делегата. Когда метод вызывается, его селектор отыскивается в массиве сигнатур и, если найден, вызывается соответствующая функция (как `delegate:function`). Специальны функции - это `setFeature(name, value, userInfo)` и `removeFeature(name, userInfo)` которые вызываются во время изменения и удаления признака. Также может быть функция `dealloc()`, вызываемая во время удаления делегата.

Пример класса делегата:
{{{

delegateClass =
{
	--общее для всех экземпляров
	signatures =
	{
		"d getV";
		"v setV:d";
	}
}
function delegateClass:new()
	return setmetatable(
	{
		--специфичное для каждого экземпляра
		v=0
	}, {__index = delegateClass} )
end

function delegateClass:getV()
	return self.v
end

function delegateClass:setV(newv)
	self.v = newv
end

function delegateClass:setFeature(name, value, par)
	MPLog(name)
	MPLog(value)
	for k,v in pairs(par) do
		MPLog(k.." "..v)
	end
end

function delegateClass:removeFeature(name)
	MPLog(name)
end
}}}
