#summary документация по Lua API для MPLuaSubject
#labels Phase-Implementation,Featured

=Привязки Lua к plainEngine= 
_Предоставляют полное API plainEngine для Lua_

<wiki:toc max_depth="3" />

==Основы==
В скрипте могут быть функции _'init', 'start', 'update'_ и _'stop'_.
		* `init()` - функция, вызываемая во время запуска субъекта. Она должна содержать код инициализации (создание обьектов, регистрация делегатов и т.д.) и не должна содержать какого-либо кода, зависящего от других субъектов (например, делегируемые вызовы), так как необходимые субъекты могут быть неинициализированы.
		* `start()`- функция, вызываемая во время первого обновления. Она может содержать код, зависящий от других субъектов, так как они уже были инициализированы во время `init`.
		* `update()` - функция, вызываемая в каждое обновление.
		* `stop()` - функция, вызываемая при выходе. Должна содержать код деинициализации и не должна содержать код, зависящий от других субъектов, так как они могут быть уже деинициализированы.

Эти функции не должны возвращать никакого значения.

==Работа с логом==
Чтобы отправить сообщение в лог, следует использовать функцию `MPLog(level, msg)`
Первый аргумент - это уровень лога (следует использовать константы уровня - _(info, notice, warning, и т.д.)_). Второй аргумент - это строка, которая должна быть отправлена в лог. Также можно использовать `MPLog(msg)`, что будет эквивалентно `MPLog(notice, msg)`.

==Yield'ы==
Чтобы использовать plainEngine yields, вызывайте функцию `MPYield()`.

==Отправление сообщения==
Чтобы отправить plainEngine-сообщение, следует использовать функцию `MPPostMessage(name[, paramsTable])`. Первый агрумент - это собственно, имя сообщения. Второй (опциональный) аргумент - это lua-таблица с параметрами сообщения.

==Отправление запроса==
Чтобы отправить plainEngine-запрос, следует использовать функцию `MPPostRequest(name[, paramsTable])`. Первый агрумент - имя запроса. Второй (опциональный) аргумент - это lua-таблица с параметрами запроса. Возвращаемое значение - строка с результатом (пустая строка, если такового нет).

==Обработка сообщения==
Чтобы обработать какое-либо сообщение, следует объявить функцию - поле таблицы _MPMessageHandlers_ - `MPMessageHandlers.<имя_сообщения>(args)`.
Первым и единственным аргументом передастся lua-таблица с параметрами сообщения. Если вы хотите установить обработчик любого сообщения, объявите функцию `MPHandlerOfAnyMessage(name, args)`. Тогда первым аргументом передастся имя сообщения, и вторым - таблица параметров.

==Работа с объектами==
Во-первых, обьект - это userinfo с метатаблицей, отвечающей на 4 события - `__index` (которое связывает имена методов с функциями), `__newindex` (который предоставляет простой интерфейс для установки значения признаков), `__eq` и `__gc`.

Пока вы можете обратиться к обьекту в вашем скрипте, он является "retained" (Термин Objective-C, означает, что не может быть уничтожен).

Чтобы получить _MPObject_, зная его имя, вам стоит либо использовать таблицу `MPObjects` (ключом является имя обьекта, значением - сам обьект) или функцию `MPObjectByName(name)`. Для получения обьекта по его handle, используйте `MPObjectByHandle(handle)`. Если обьект не найден, вернётся *nil*.

Чтобы создать обьект plainEngine, следует использовать функции `MPNewObject(name)` и `MPCreateObject(name)`. Разница заключается в том, что обьекты, созданные с помощью `MPNewObject`, *должны быть* освобождены вручную с помощью `object.release`, а обьекты, созданные с помощью `MPCreateObject` *НЕ должны быть* уничтожены вручную, так как они будут освобождены автоматически после остановки.

Также можно использовать функции `MPGetAllObjects()` (возвращает массив всех обьектов) и `MPGetObjectsByFeature(featurename)` (возвращает массив всех обьектов с заданным признаком).

Чтобы обращаться к методам обьекта, следует использовать `object:methodname` (или `object["methodName"](object, ...)` ). Результатом будет функция, аналогичная соответвующему методу. Если имя метода содержит символы ':', вы не можете использовать форму object:methodName, но вы можете использовать _MPMethodAliasTable_. Это глобальная таблица, которая отображает псевдонимы методов на их реальные имена. При вызове метода, в первую очередь проверяется наличие псевдонима для него. Если таковой есть, вызывается метод, соответствующий своему псевдониму. Например, вы хотите сделать выражение`obj["setXYZ:::"](obj 0, 0, 0)` менее уродливым.
Тогда, в 'start', вы обьявляете:
{{{
function start()
	...
	MPMethodAliasTable["setXYZ"] = "setXYZ:::"
	...
end
}}}
И затем, вы можете вызывать `obj:setXYZ(0, 0, 0)`.

Некоторые методы MPObject переопределены в lua-обьекте, так как они использовали типы, не поддерживаемые lua. Это:
		
  # `object:getName()` - возвращает строку с именем обьекта;
  # `object:getHandle()` - возвращает handle обьекта как `number`;
  # `object:hasFeature(fname)` - возвращает `true`, если обьект имеет признак fname и `false` в противном случае;
  # `object:copy()` - возвращает копию обьекта;
  # `object:copyWithName(copyname)` - возвращает копию обьекта с именем _'copyname'_;
  # `object:getAllFeatures()` - возвращает таблицу с названиями признаков в качестве ключей и их значениями в качестве значений (таблицы);
  # `object:getFeatureData(fname)` - возвращает строку со значением признака _'fname'_;
  # `object:setFeature(fname[, fvalue [,paramsTable]])`	- меняет значение признака _'fname'_ на _'fvalue'_ (значение по умолчанию - пустая строка) и paramsTable как userInfo;
  # `object:removeFeature(fname[, paramsTable])` - удаляет признак 'fname' у object, отправляя paramsTable как userInfo при наличии такового;
  # `object:respondsTo(selName)` - возвращает `true`, если object отвечает на селектор метода _`selName`_ и `false` в противном случае.

Если вы хотите сменить значение признака обьекта на некоторое значение без отправления каких-либо параметров, вы можете написать
{{{ 
object.featurename = featurevalue 
}}}
вместо
{{{
object:setFeature(featurename, featurevalue); 
}}}

Но чтение признаков таким образом работать не будет, так как object.name означает метод 'name'.

==Обьявление классов делегатов==
В Lua, класс делегата это таблица, содержащая функцию 'delegateClassTable:newDelegateWithObject(object)' или 'delegateClassTable:new()'. Если вы хотите зарегистрировать класс делегата, используйте функцию `MPRegisterDelegateClass(delegateClassTable)` или `MPRegisterDelegateClassForFeature(delegateClassTable, featureName)`.

Делегаты инстанцируются через функции класса делегата (`newDelegateWithObject` или `new`). Каждый делегат должен содержать таблицу 'signatures', являющуюся массивом сигнатур метода (тип - `string`) вида: `"<R> methodname:<t1> :<t2> namedparam:<t3>"`, где `<R>` - это тип возвращаемого значения, `t1` - это тип первого аргумента и т.д. (например "double getX" или "void setXYZ:double:double:double"). 

Типы, поддерживаемые субъектом Lua:

|| *тип C* || *имя типа для Lua* ||
|| `double` || `double` ||
|| `float` || `float` ||
|| `long` || `long` ||
|| `unsigned long` || `ulong` ||
|| `long long` || `longlong` ||
|| `unsigned long long` || `ulonglong` ||
|| `char` || `char` ||
|| `unsigned char` || `uchar` ||
|| `short` || `short` ||
|| `unsigned short` || `ushort` ||
|| `int` || `int` ||
|| `unsigned int` || `uint` ||
|| `MPHandle` || `mphandle` ||

Сигнатуры могут свободно меняться на протяжении существования делегата. Когда метод вызывается, его селектор отыскивается в массиве сигнатур и, если найден, вызывается соответствующая функция (как `delegate:function`). Специальными функциями являются `setFeature(name, value, userInfo)` и `removeFeature(name, userInfo)` которые вызываются во время изменения и удаления признака. Также может быть функция `dealloc()`, вызываемая во время удаления делегата.

Пример класса делегата:
{{{

delegateClass =
{
	--общее для всех экземпляров
	signatures =
	{
		"double getV";
		"void setV:double";
	}
}
function delegateClass:new()
	return setmetatable(
	{
		--специфичное для каждого экземпляра
		v=0
	}, {__index = delegateClass} )
end

function delegateClass:getV()
	return self.v
end

function delegateClass:setV(newv)
	self.v = newv
end

function delegateClass:setFeature(name, value, par)
	MPLog(name)
	MPLog(value)
	for k,v in pairs(par) do
		MPLog(k.." "..v)
	end
end

function delegateClass:removeFeature(name)
	MPLog(name)
end
}}}
